\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{float}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage[affil-it]{authblk}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{listings}
 

\usepackage{xcolor}
\usepackage{newunicodechar}

\newcommand\Warning{%
 \makebox[1.4em][c]{%
 \makebox[0pt][c]{\raisebox{.1em}{\small!}}%
 \makebox[0pt][c]{\color{red}\Large$\bigtriangleup$}}}%

\newunicodechar{⚠}{\Warning}

\lstset{language=c++}

\author{Scander Mustapha}
\title{Distributed Join Processing\\ on Social Network Data}
\affil{\'Ecole polytechnique}



\begin{document}
\maketitle
\let\olditem\item
\renewcommand{\item}{\olditem[$\bullet$]}

Ce rapport a pour objet de présenter l'implémentation et les résultats du projet "Distributed Join Processing on Social Network Data". Le code est disponible sur le repo \footnote{\url{https://github.com/intermet/inf442}}. Nous avons implémenté une structure de donnée représentant une relation, la jointure séquentielle et distribuée d'atomes , ainsi que la jointure hypercube.

\section{Généralités}
Soient $R_1$ et $R_2$ deux relations sur des entiers naturels.
Notons $a_1 \in \mathbb{N}$ (resp. $a_2 \in \mathbb{N}$) l'arité de $R_1$ (resp. $R_2$).

Considérons des variables $(x_1, \dots, x_{a_1})$ et $(y_1, \dots, y_{a_2})$, éventuellement non distinctes.

\section{Présentation des résultats}

\subsection{Jointure}
Nous avons calculé les chemins de longueurs deux et les triangles pour différentes relations: un graphe particulier et les données \verb?facebook.dat? et \verb?dblp.dat?.
Les résultats sont présentés sous la forme de graphe: le temps d'exécution moyen sur 10 exécutions en fonction du nombre de processeurs utilisés - de 1 (séquentiel) à 12 - pour un jointure utilisant l'implémentation de la Task 3 (gather root puis scatter) ou l'implémentation de la Task 7 (scatters locaux puis gather final).
Nous avons utilisé \verb?python? et la bibliothéque \verb?pandas? \footnote{\url{https://pandas.pydata.org/}} pour vérifier nos résultats (cf \verb?check.py?).


\large{\textbf{Attention}}: que ce soit avec la Task 3 ou la Task 7 (et peu importe le nombre de processeurs, et même avec le script \verb?python?), les jointures de \verb?twitter.dat? ont échouées pour cause de manque de mémoire (cf section \ref{sec:hypercube}). 


\subsubsection*{Exemple graphe particulier}


\subsubsection*{Résumé des données}
\begin{figure}[H]
  \centering
  \begin{tabular}{cccc}
    & Nombre d'entrées & Nombre de chemin de longueur 2& Nombre de triangles \\
    \hline
    \verb?facebook.dat? &  176.468 & 18.806.166 & 5083\\
    \hline
    \verb?dblp.dat? & 2.099.732 & 45.661.510 & 40\\
    \hline
    \verb?twitter.dat? & 4.841.532 & ?? & ??\\
  \end{tabular}
  \caption{\label{fig:table} Résumé des données facebook.dat et dblp.dat}
\end{figure}


\begin{multicols}{2}
\begin{figure}[H]
  \centering
  \includegraphics[width=9cm]{plot/fb_simple.png}
  \caption{\label{fig:fb_simple} Calcul des chemins de longueur 2 \hspace*{4cm} dans facebook.dat }
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=9cm]{plot/db_simple.png}
  \caption{\label{fig:fb_simple} Calcul des chemins de longueur 2 \hspace*{4cm} dans dblp.dat }
\end{figure}

\end{multicols}

\subsubsection*{Commentaires}
\begin{itemize}
\item une execution séquentielle est toujours plus efficace: ceci s'explique par le fait que les communications sont trop coûteuses, et que le temps gagné lors de la parrallélisation est perdu lors des communications. 
\item cependant, à partir d'un certains seuil du nombre de processeurs (au alentour de 8), la distribution devient efficace, même si c'est toujours moins efficace qu'une execution séquentielle.
\item l'implémentation de la Task 6 est légèrement plus efficace
\end{itemize}


\begin{multicols}{2}
\begin{figure}[H]
  \centering
  \includegraphics[width=9cm]{plot/fb_tri.png}
  \caption{\label{fig:fb_simple} Calcul des triangles dans facebook.dat }
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=9cm]{plot/db_tri.png}
  \caption{\label{fig:fb_simple} Calcul des chemins de longueur 2 \hspace*{4cm} dans dblp.dat }
\end{figure}

\end{multicols}

\subsubsection*{Commentaires}
\begin{itemize}
\item c'est pareil, l'exectution séquentiel est toujours plus efficace, et il y a toujours un seuil pour 8 processeurs. 
\end{itemize}


\vspace*{2cm}
\large{\textbf{Conclusion}}
Les communications sont beaucoup trop coûteuses, et ne permet pas de jointure sur de relations trop grande d'où l'inétêret de l'algorithme suivant. 

\section{Jointure hypercube}
\label{sec:hypercube}



\end{document}
